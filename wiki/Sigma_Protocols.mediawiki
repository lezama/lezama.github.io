== In general ==

Sigma protocols involve a verifier (A) and prover (B).
They suppose that Alice and Bob share a public input <math>v</math> and agree on an efficiently testable relation <math>R</math>, and that Bob pretends to have a private input <math>w</math>:
* such that <math>(v,w)\in R</math>;
* which he does does not want to disclose.
Through the protocol, Bob will seek to convince Alice.

The protocol has three rounds:
:<math> B\rightarrow A: a=a(v,R,w) </math>
:<math> A\rightarrow B: c=c(v,R,a) </math>
:<math> B\rightarrow B: r=r(v,R,w,a,c,w) </math>
Lastly, Alice checks that Bob response <math>r</math> to her challenge <math>r</math> is valid. This explains what the last two rounds are for. The first round is there out of technical necessity: Bob chooses this <math>a</math> as a mask for passing the challenge without disclosing <math>w</math>.

== Example ==

Here is an example based on Discrete Logarithms. Take <math>p</math> a prime and <math>g</math> an integer. The powers of <math>g</math> form a subgroup <math>G_q</math> (having <math>q</math> elements) inside the group <math>Z_p</math> (having <math>p</math> elements), which is that of integers modulo <math>p</math>. The choice of these <math>p</math> and <math>g</math> is important so that they meet the [http://en.wikipedia.org/wiki/Decisional_Diffie%E2%80%93Hellman_assumption Decisional Diffie-Hellman] assumption; but there are standard techniques for doing that.

* Public input <math>v\in G_q</math>.
* Agreed relation <math>(v,w)\in R \Leftrightarrow g^w=v</math>.
* Private input <math>w</math>.
* Bob will need some random <math>u\in Z_p</math>, Alice will need some random <math>c\in Z_p</math>. 
The protocol has three rounds:
:<math> B\rightarrow A: a=g^u </math>
:<math> A\rightarrow B: c </math>
:<math> B\rightarrow B: r=wc+u </math>
Alice validates Bob response by checking that <math>g^r=ah^c</math>. Indeed, 
:<math>g^r=g^{wc}g^u=h^ca.</math>